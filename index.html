<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tezos Walkman Pro</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        body {
            font-family: 'Orbitron', 'Arial Black', sans-serif;
            background: #000000;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 40px 20px;
            position: relative;
            overflow: hidden;
        }

        /* Animated vaporwave grid background */
        body::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                linear-gradient(0deg, transparent 24%, rgba(255, 215, 0, 0.08) 25%, rgba(255, 215, 0, 0.08) 26%, transparent 27%, transparent 74%, rgba(255, 215, 0, 0.08) 75%, rgba(255, 215, 0, 0.08) 76%, transparent 77%, transparent),
                linear-gradient(90deg, transparent 24%, rgba(255, 110, 199, 0.06) 25%, rgba(255, 110, 199, 0.06) 26%, transparent 27%, transparent 74%, rgba(255, 110, 199, 0.06) 75%, rgba(255, 110, 199, 0.06) 76%, transparent 77%, transparent);
            background-size: 60px 60px;
            background-position: 0 0;
            transform: perspective(600px) rotateX(60deg) translateZ(0);
            transform-origin: center bottom;
            animation: gridMove 25s linear infinite;
            opacity: 0.4;
            pointer-events: none;
            z-index: 0;
        }

        @keyframes gridMove {
            0% { background-position: 0 0; }
            100% { background-position: 0 60px; }
        }

        /* Subtle top gradient glow */
        body::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(ellipse at top, rgba(255, 215, 0, 0.05) 0%, transparent 40%),
                radial-gradient(ellipse at center, rgba(255, 110, 199, 0.03) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
        }

        /* Scanlines effect */
        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                rgba(255, 215, 0, 0.02) 0px,
                transparent 1px,
                transparent 2px,
                rgba(255, 110, 199, 0.02) 3px
            );
            pointer-events: none;
            z-index: 1;
            animation: scanlineMove 10s linear infinite;
        }

        @keyframes scanlineMove {
            0% { transform: translateY(0); }
            100% { transform: translateY(4px); }
        }

        .container {
            width: 100%;
            max-width: 420px;
            max-height: 90vh;
            perspective: 1500px;
            position: relative;
            z-index: 10;
        }

        .walkman {
            background: 
                linear-gradient(145deg, rgba(10, 10, 10, 0.95), rgba(20, 20, 30, 0.9));
            border-radius: 28px;
            padding: 25px 25px 20px 25px;
            box-shadow: 
                0 30px 80px rgba(0, 0, 0, 0.8),
                0 15px 40px rgba(255, 215, 0, 0.2),
                inset 0 -8px 25px rgba(0, 0, 0, 0.6),
                inset 0 8px 25px rgba(255, 215, 0, 0.1),
                inset 2px 0 15px rgba(255, 215, 0, 0.15),
                inset -2px 0 15px rgba(255, 110, 199, 0.1);
            position: relative;
            border: 3px solid rgba(255, 215, 0, 0.3);
            transform: translateZ(0);
            transition: all 0.3s ease;
            backdrop-filter: blur(20px);
            overflow: hidden;
        }

        /* Animated vaporwave grid INSIDE the player */
        .walkman::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                linear-gradient(0deg, transparent 24%, rgba(255, 215, 0, 0.25) 25%, rgba(255, 215, 0, 0.25) 26%, transparent 27%, transparent 74%, rgba(255, 215, 0, 0.25) 75%, rgba(255, 215, 0, 0.25) 76%, transparent 77%, transparent),
                linear-gradient(90deg, transparent 24%, rgba(255, 110, 199, 0.2) 25%, rgba(255, 110, 199, 0.2) 26%, transparent 27%, transparent 74%, rgba(255, 110, 199, 0.2) 75%, rgba(255, 110, 199, 0.2) 76%, transparent 77%, transparent);
            background-size: 35px 35px;
            background-position: 0 0;
            transform: perspective(300px) rotateX(55deg) scale(2) translateY(-80px);
            transform-origin: center center;
            animation: innerGridMove 8s linear infinite, gridPulse 2s ease-in-out infinite;
            opacity: var(--grid-opacity, 0.5);
            border-radius: 28px;
            pointer-events: none;
            z-index: 0;
            filter: blur(0.3px);
        }

        @keyframes innerGridMove {
            0% { background-position: 0 0; }
            100% { background-position: 0 35px; }
        }

        @keyframes gridPulse {
            0%, 100% { 
                opacity: var(--grid-opacity, 0.5);
                transform: perspective(300px) rotateX(55deg) scale(var(--grid-scale, 2)) translateY(-80px);
            }
            50% { 
                opacity: calc(var(--grid-opacity, 0.5) * 1.3);
                transform: perspective(300px) rotateX(55deg) scale(calc(var(--grid-scale, 2) * 1.05)) translateY(-80px);
            }
        }

        /* Radiant glow layer */
        .walkman-glow {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 100%;
            height: 100%;
            transform: translate(-50%, -50%);
            background: 
                radial-gradient(ellipse at center, rgba(255, 215, 0, var(--glow-intensity, 0.15)) 0%, transparent 60%),
                radial-gradient(ellipse at center, rgba(255, 110, 199, var(--glow-intensity, 0.1)) 20%, transparent 70%);
            border-radius: 28px;
            pointer-events: none;
            z-index: 0;
            animation: glowPulse 2s ease-in-out infinite;
        }

        @keyframes glowPulse {
            0%, 100% { 
                opacity: 1; 
                transform: translate(-50%, -50%) scale(1);
            }
            50% { 
                opacity: 1.3; 
                transform: translate(-50%, -50%) scale(1.08);
            }
        }

        /* Audio reactive glow layer */
        .walkman::after {
            content: '';
            position: absolute;
            top: -5px;
            left: -5px;
            right: -5px;
            bottom: -5px;
            background: transparent;
            border-radius: 32px;
            pointer-events: none;
            z-index: -1;
            transition: box-shadow 0.1s ease;
        }

        .walkman.audio-react::after {
            animation: audio-pulse 0.1s ease;
        }

        @keyframes audio-pulse {
            0% { 
                box-shadow: 
                    0 0 30px rgba(255, 215, 0, 0.4),
                    0 0 60px rgba(255, 215, 0, 0.2),
                    inset 0 0 30px rgba(255, 215, 0, 0.1);
            }
            50% { 
                box-shadow: 
                    0 0 60px rgba(255, 215, 0, 0.8),
                    0 0 120px rgba(255, 110, 199, 0.4),
                    inset 0 0 60px rgba(255, 215, 0, 0.2);
            }
            100% { 
                box-shadow: 
                    0 0 30px rgba(255, 215, 0, 0.4),
                    0 0 60px rgba(255, 215, 0, 0.2),
                    inset 0 0 30px rgba(255, 215, 0, 0.1);
            }
        }

        .walkman:hover {
            transform: translateZ(10px);
            box-shadow: 
                0 35px 90px rgba(0, 0, 0, 0.9),
                0 20px 50px rgba(255, 215, 0, 0.3),
                inset 0 -8px 25px rgba(0, 0, 0, 0.6),
                inset 0 8px 25px rgba(255, 215, 0, 0.15);
        }

        /* Make sure all content is above the background layers */
        .walkman > * {
            position: relative;
            z-index: 1;
        }

        /* Remove top clips */
        .top-clips {
            display: none;
        }

        .clip {
            display: none;
        }

        /* Remove side buttons */
        .side-btn {
            display: none;
        }

        /* Top clips/buttons */
        .top-clips {
            position: absolute;
            top: -18px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 80px;
            z-index: 10;
        }

        .clip {
            width: 50px;
            height: 35px;
            background: 
                linear-gradient(145deg, #1a1a1a 0%, #0a0a0a 100%);
            border-radius: 10px 10px 0 0;
            border: 4px solid rgba(255, 215, 0, 0.3);
            border-bottom: none;
            position: relative;
            box-shadow: 
                0 -5px 15px rgba(0, 0, 0, 0.8),
                inset 0 3px 8px rgba(255, 215, 0, 0.1),
                inset 0 -3px 8px rgba(0, 0, 0, 0.8);
        }

        .clip::before {
            content: '';
            position: absolute;
            top: 12px;
            left: 50%;
            transform: translateX(-50%);
            width: 28px;
            height: 10px;
            background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
            border-radius: 3px;
            box-shadow: 
                inset 0 2px 4px rgba(0, 0, 0, 0.8),
                0 1px 2px rgba(255, 215, 0, 0.2);
        }

        /* Logo */
        .logo {
            text-align: right;
            font-size: 18px;
            font-weight: 900;
            letter-spacing: 2px;
            color: #ffd700;
            margin-bottom: 20px;
            font-family: 'Orbitron', sans-serif;
            text-shadow: 
                0 0 20px rgba(255, 215, 0, 0.8),
                0 0 40px rgba(255, 215, 0, 0.4),
                2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        /* Status LEDs */
        .status-leds {
            position: absolute;
            top: 30px;
            left: 30px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .led-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .led {
            width: 12px;
            height: 12px;
            background: 
                radial-gradient(circle at 30% 30%, #ffd700, #ffaa00);
            border-radius: 50%;
            box-shadow: 
                0 0 20px rgba(255, 215, 0, 1),
                0 0 40px rgba(255, 215, 0, 0.6),
                inset 0 -3px 6px rgba(0, 0, 0, 0.4),
                inset 0 2px 4px rgba(255, 255, 255, 0.4);
            position: relative;
            animation: led-pulse 2s ease-in-out infinite;
        }

        @keyframes led-pulse {
            0%, 100% { box-shadow: 0 0 20px rgba(255, 215, 0, 1), 0 0 40px rgba(255, 215, 0, 0.6), inset 0 -3px 6px rgba(0, 0, 0, 0.4); }
            50% { box-shadow: 0 0 30px rgba(255, 215, 0, 1), 0 0 60px rgba(255, 215, 0, 0.8), inset 0 -3px 6px rgba(0, 0, 0, 0.4); }
        }

        .led::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 5px;
            height: 5px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            filter: blur(1px);
        }

        .led.off {
            background: 
                radial-gradient(circle at 30% 30%, #3a3a00, #1a1a00);
            box-shadow: 
                inset 0 2px 6px rgba(0, 0, 0, 0.9),
                0 1px 2px rgba(0, 0, 0, 0.5);
            animation: none;
        }

        .led.off::after {
            display: none;
        }

        .led-label {
            font-size: 9px;
            font-weight: 700;
            color: #ffd700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.6);
        }

        /* Control pod - the circular visualizer section */
        .control-pod {
            width: 200px;
            height: 200px;
            background: 
                radial-gradient(circle at 30% 30%, #1e1e2e, #0a0a15);
            border-radius: 50%;
            margin: 0 auto 20px;
            position: relative;
            box-shadow: 
                0 15px 40px rgba(0, 0, 0, 0.6),
                0 8px 20px rgba(0, 0, 0, 0.4),
                inset 0 -8px 20px rgba(0, 0, 0, 0.6),
                inset 0 8px 20px rgba(255, 255, 255, 0.05),
                inset 0 0 60px rgba(120, 115, 245, 0.1);
            border: 6px solid #0a0a0a;
            overflow: hidden;
        }

        .control-pod::before {
            content: '';
            position: absolute;
            top: 10%;
            left: 10%;
            width: 30%;
            height: 30%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.1), transparent);
            border-radius: 50%;
            filter: blur(10px);
        }

        /* Vaporwave mountains canvas */
        .mountains {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        /* Visualizer canvas */
        .visualizer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* Center FM label */
        .pod-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #ff6ec7;
            font-size: 14px;
            font-weight: 900;
            font-family: 'Orbitron', sans-serif;
            z-index: 2;
            text-shadow: 
                0 0 20px rgba(255, 110, 199, 0.8),
                0 0 40px rgba(255, 110, 199, 0.4);
            letter-spacing: 4px;
        }

        /* Fullscreen button */
        .fullscreen-btn {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 30px;
            height: 30px;
            background: rgba(255, 215, 0, 0.2);
            border: 2px solid rgba(255, 215, 0, 0.5);
            border-radius: 6px;
            color: #ffd700;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3;
            transition: all 0.3s ease;
        }

        .fullscreen-btn:hover {
            background: rgba(255, 215, 0, 0.4);
            border-color: #ffd700;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.6);
        }

        /* Fullscreen mode */
        .fullscreen-visualizer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            z-index: 9999;
            display: none;
        }

        .fullscreen-visualizer.active {
            display: block;
        }

        .fullscreen-canvas {
            width: 100%;
            height: 100%;
        }

        .fullscreen-mountains {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .fullscreen-controls {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 20px;
            padding: 20px 40px;
            background: rgba(10, 10, 10, 0.8);
            border-radius: 60px;
            border: 2px solid rgba(255, 215, 0, 0.3);
            backdrop-filter: blur(20px);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
            z-index: 10;
        }

        .fullscreen-info {
            display: flex;
            flex-direction: column;
            margin-right: 20px;
        }

        .fullscreen-title {
            font-size: 16px;
            font-weight: 900;
            color: #00ffcc;
            margin-bottom: 4px;
            font-family: 'Orbitron', sans-serif;
            text-shadow: 0 0 15px rgba(0, 255, 204, 0.8);
            cursor: pointer;
        }

        .fullscreen-title:hover {
            color: #fff;
        }

        .fullscreen-artist {
            font-size: 12px;
            color: #ff6ec7;
            font-family: 'Orbitron', sans-serif;
            text-shadow: 0 0 10px rgba(255, 110, 199, 0.6);
        }

        .fullscreen-control-btn {
            width: 50px;
            height: 50px;
            background: linear-gradient(145deg, #2d2d3f, #1a1a2a);
            border-radius: 50%;
            border: 3px solid rgba(255, 215, 0, 0.3);
            color: #00ffcc;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .fullscreen-control-btn:hover {
            border-color: #ffd700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
            transform: scale(1.1);
        }

        .fullscreen-control-btn.play {
            width: 60px;
            height: 60px;
            background: linear-gradient(145deg, #ff6ec7, #d84fa8);
            font-size: 22px;
            color: #fff;
        }

        .fullscreen-exit {
            position: absolute;
            top: 30px;
            right: 30px;
            width: 50px;
            height: 50px;
            background: rgba(255, 215, 0, 0.2);
            border: 2px solid rgba(255, 215, 0, 0.5);
            border-radius: 50%;
            color: #ffd700;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 11;
            transition: all 0.3s ease;
        }

        .fullscreen-exit:hover {
            background: rgba(255, 215, 0, 0.4);
            border-color: #ffd700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
        }

        /* Control buttons below visualizer */
        .controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin-bottom: 25px;
        }

        .control-btn {
            width: 55px;
            height: 55px;
            background: 
                linear-gradient(145deg, #2d2d3f, #1a1a2a);
            border-radius: 50%;
            border: 4px solid #0a0a0a;
            color: #00ffcc;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 
                0 6px 20px rgba(0, 0, 0, 0.4),
                inset 0 2px 6px rgba(255, 255, 255, 0.1),
                inset 0 -2px 6px rgba(0, 0, 0, 0.5);
            position: relative;
        }

        .control-btn::before {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.2), transparent);
            border-radius: 50%;
            filter: blur(3px);
        }

        .control-btn:hover {
            transform: translateY(-3px);
            box-shadow: 
                0 10px 30px rgba(0, 255, 204, 0.4),
                inset 0 2px 6px rgba(255, 255, 255, 0.2),
                inset 0 -2px 6px rgba(0, 0, 0, 0.5);
            color: #00ffcc;
            text-shadow: 0 0 10px rgba(0, 255, 204, 0.8);
        }

        .control-btn:active {
            transform: translateY(-1px);
        }

        /* Main play button - bigger and centered */
        .control-btn.play {
            width: 75px;
            height: 75px;
            background: 
                linear-gradient(145deg, #ff6ec7, #d84fa8);
            border: 5px solid #0a0a0a;
            color: #fff;
            font-size: 28px;
            box-shadow: 
                0 8px 30px rgba(255, 110, 199, 0.5),
                inset 0 3px 10px rgba(255, 255, 255, 0.2),
                inset 0 -3px 10px rgba(0, 0, 0, 0.4);
        }

        .control-btn.play::before {
            width: 30px;
            height: 30px;
            top: 5px;
            left: 5px;
        }

        .control-btn.play:hover {
            box-shadow: 
                0 12px 40px rgba(255, 110, 199, 0.7),
                0 0 60px rgba(255, 110, 199, 0.4),
                inset 0 3px 10px rgba(255, 255, 255, 0.3),
                inset 0 -3px 10px rgba(0, 0, 0, 0.4);
        }

        /* Side buttons */
        .side-btn {
            position: absolute;
            width: 45px;
            height: 24px;
            background: 
                linear-gradient(145deg, #f5f5f5, #d0d0d0);
            border-radius: 10px;
            border: 3px solid #0a0a0a;
            cursor: pointer;
            box-shadow: 
                0 4px 12px rgba(0, 0, 0, 0.4),
                inset 0 2px 4px rgba(255, 255, 255, 0.4),
                inset 0 -2px 4px rgba(0, 0, 0, 0.2);
            transition: all 0.2s;
        }

        .side-btn:active {
            transform: translateY(2px);
            box-shadow: 
                0 2px 6px rgba(0, 0, 0, 0.4),
                inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .side-btn.off {
            top: 35px;
            right: -18px;
            background: linear-gradient(145deg, #ffffff, #e8e8e8);
            font-size: 9px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 900;
            color: #0a0a0a;
            font-family: 'Orbitron', sans-serif;
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.5);
        }

        .side-btn.mode {
            top: 75px;
            right: -18px;
        }

        /* Track display section */
        .track-display {
            background: 
                linear-gradient(145deg, #0f0f1f, #050508);
            border-radius: 15px;
            padding: 15px;
            margin-bottom: 18px;
            border: 4px solid #0a0a0a;
            box-shadow: 
                inset 0 4px 15px rgba(0, 0, 0, 0.9),
                inset 0 -2px 8px rgba(120, 115, 245, 0.1),
                0 4px 20px rgba(0, 0, 0, 0.3);
            min-height: 85px;
            position: relative;
            overflow: hidden;
        }

        .track-display::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, 
                transparent 0%, 
                rgba(0, 255, 204, 0.3) 25%, 
                rgba(255, 110, 199, 0.3) 75%, 
                transparent 100%
            );
        }

        .track-title {
            font-size: 16px;
            font-weight: 900;
            color: #00ffcc;
            margin-bottom: 10px;
            text-shadow: 
                0 0 20px rgba(0, 255, 204, 1),
                0 0 40px rgba(0, 255, 204, 0.5),
                0 2px 4px rgba(0, 0, 0, 0.8);
            font-family: 'Orbitron', sans-serif;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .track-title:hover {
            color: #fff;
            text-shadow: 
                0 0 25px rgba(0, 255, 204, 1),
                0 0 50px rgba(0, 255, 204, 0.8),
                0 2px 4px rgba(0, 0, 0, 0.8);
            transform: translateX(3px);
        }

        .track-title a {
            color: inherit;
            text-decoration: none;
        }

        .track-artist {
            font-size: 13px;
            color: #ff6ec7;
            text-shadow: 
                0 0 15px rgba(255, 110, 199, 0.8),
                0 0 30px rgba(255, 110, 199, 0.4),
                0 2px 4px rgba(0, 0, 0, 0.6);
            font-family: 'Orbitron', sans-serif;
            font-weight: 600;
        }

        .progress-container {
            margin-top: 15px;
            background: #000;
            border-radius: 5px;
            height: 8px;
            overflow: hidden;
            border: 2px solid #1a1a1a;
            box-shadow: 
                inset 0 2px 6px rgba(0, 0, 0, 0.8),
                0 1px 2px rgba(120, 115, 245, 0.2);
            position: relative;
        }

        .progress-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #ff6ec7, #7873f5, #00ffcc);
            transition: width 0.3s ease;
            box-shadow: 
                0 0 15px rgba(0, 255, 204, 0.8),
                0 0 30px rgba(255, 110, 199, 0.6);
            position: relative;
        }

        .progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 4px;
            height: 100%;
            background: #fff;
            box-shadow: 0 0 8px #fff;
        }

        /* Bottom branding */
        .bottom-brand {
            text-align: center;
            margin-top: 15px;
            margin-bottom: 15px;
        }

        .sports-text {
            font-size: 11px;
            font-weight: 900;
            color: #1a1a1a;
            letter-spacing: 3px;
            font-family: 'Orbitron', sans-serif;
            text-shadow: 
                1px 1px 0px rgba(255, 255, 255, 0.3),
                -1px -1px 0px rgba(0, 0, 0, 0.2);
        }

        .walkman-fm {
            font-size: 30px;
            font-weight: 900;
            color: #0a0a0a;
            letter-spacing: 0px;
            line-height: 1;
            font-family: 'Orbitron', sans-serif;
            text-shadow: 
                2px 2px 0px rgba(255, 255, 255, 0.4),
                -1px -1px 0px rgba(0, 0, 0, 0.2),
                3px 3px 8px rgba(0, 0, 0, 0.3);
        }

        /* Input section */
        .input-section {
            margin-bottom: 18px;
        }

        .input-wrapper {
            display: flex;
            gap: 10px;
        }

        input {
            flex: 1;
            background: rgba(15, 15, 31, 0.8);
            border: 3px solid #1a1a1a;
            border-radius: 10px;
            padding: 12px 15px;
            color: #00ffcc;
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            font-weight: 600;
            outline: none;
            box-shadow: 
                inset 0 3px 10px rgba(0, 0, 0, 0.6),
                0 2px 8px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
        }

        input:focus {
            border-color: #00ffcc;
            box-shadow: 
                inset 0 3px 10px rgba(0, 0, 0, 0.6),
                0 0 20px rgba(0, 255, 204, 0.4),
                0 0 40px rgba(0, 255, 204, 0.2);
            text-shadow: 0 0 8px rgba(0, 255, 204, 0.6);
        }

        input::placeholder {
            color: rgba(0, 255, 204, 0.3);
            font-weight: 400;
        }

        .add-btn {
            background: 
                linear-gradient(145deg, #00ffcc, #00d4aa);
            border: 3px solid #0a0a0a;
            border-radius: 10px;
            padding: 12px 22px;
            color: #0a0a0a;
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            font-weight: 900;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 
                0 6px 15px rgba(0, 255, 204, 0.4),
                inset 0 2px 6px rgba(255, 255, 255, 0.3),
                inset 0 -2px 6px rgba(0, 0, 0, 0.2);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .add-btn:hover {
            transform: translateY(-3px);
            box-shadow: 
                0 10px 25px rgba(0, 255, 204, 0.6),
                0 0 40px rgba(0, 255, 204, 0.3),
                inset 0 2px 6px rgba(255, 255, 255, 0.4),
                inset 0 -2px 6px rgba(0, 0, 0, 0.2);
        }

        .add-btn:active {
            transform: translateY(-1px);
        }

        /* Playlist */
        .playlist {
            background: rgba(15, 15, 31, 0.6);
            border-radius: 15px;
            border: 3px solid #1a1a1a;
            padding: 12px;
            max-height: 150px;
            overflow-y: auto;
            box-shadow: 
                inset 0 3px 10px rgba(0, 0, 0, 0.7),
                0 2px 10px rgba(0, 0, 0, 0.2);
        }

        .playlist::-webkit-scrollbar {
            width: 10px;
        }

        .playlist::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            margin: 5px;
        }

        .playlist::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #00ffcc, #7873f5);
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0, 255, 204, 0.5);
        }

        .playlist::-webkit-scrollbar-thumb:hover {
            box-shadow: 0 0 15px rgba(0, 255, 204, 0.8);
        }

        .playlist-item {
            padding: 10px 12px;
            margin-bottom: 8px;
            background: rgba(26, 26, 46, 0.4);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-left: 4px solid transparent;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            position: relative;
        }

        .playlist-item:hover {
            background: rgba(0, 255, 204, 0.15);
            border-left-color: #00ffcc;
            box-shadow: 
                0 4px 12px rgba(0, 255, 204, 0.3),
                inset 0 0 20px rgba(0, 255, 204, 0.1);
        }

        .playlist-item.active {
            background: rgba(255, 110, 199, 0.15);
            border-left-color: #ff6ec7;
            box-shadow: 
                0 4px 12px rgba(255, 110, 199, 0.4),
                inset 0 0 20px rgba(255, 110, 199, 0.1);
        }

        .playlist-item-title {
            color: #00ffcc;
            font-size: 12px;
            font-weight: 700;
            margin-bottom: 4px;
            font-family: 'Orbitron', sans-serif;
            text-shadow: 0 0 10px rgba(0, 255, 204, 0.6);
            padding-right: 25px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .playlist-item-title:hover {
            color: #fff;
            text-shadow: 0 0 15px rgba(0, 255, 204, 0.9);
        }

        .playlist-item-title a {
            color: inherit;
            text-decoration: none;
        }

        .playlist-item-artist {
            color: #ff6ec7;
            font-size: 11px;
            font-weight: 600;
            font-family: 'Orbitron', sans-serif;
            text-shadow: 0 0 8px rgba(255, 110, 199, 0.5);
        }

        .delete-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 20px;
            height: 20px;
            background: rgba(255, 0, 80, 0.8);
            color: #fff;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            opacity: 0;
            transition: all 0.2s ease;
            line-height: 1;
            font-family: Arial, sans-serif;
        }

        .playlist-item:hover .delete-btn {
            opacity: 1;
        }

        .delete-btn:hover {
            background: rgba(255, 0, 80, 1);
            transform: scale(1.1);
        }

        .loading {
            display: none;
            text-align: center;
            color: #00ffcc;
            font-size: 12px;
            padding: 10px;
            font-weight: 900;
            font-family: 'Orbitron', sans-serif;
            text-shadow: 0 0 15px rgba(0, 255, 204, 0.8);
        }

        .loading.active {
            display: block;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .loading.active {
            animation: pulse 1.5s ease-in-out infinite;
        }

        .status {
            text-align: center;
            color: #1a1a1a;
            font-size: 11px;
            margin-top: 15px;
            font-weight: 700;
            opacity: 0.6;
            font-family: 'Orbitron', sans-serif;
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.2);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="walkman">
            <!-- Glow layer -->
            <div class="walkman-glow"></div>
            
            <!-- Logo -->
            <div class="logo">TEZOS</div>

            <!-- Status LEDs -->
            <div class="status-leds">
                <div class="led-row">
                    <div class="led" id="led1"></div>
                    <div class="led-label">ON/PLAY</div>
                </div>
                <div class="led-row">
                    <div class="led off" id="led2"></div>
                    <div class="led-label">FM STEREO</div>
                </div>
            </div>

            <!-- Control pod with visualizer -->
            <div class="control-pod">
                <canvas class="mountains" id="mountains"></canvas>
                <canvas class="visualizer" id="visualizer"></canvas>
                <div class="pod-display">FM</div>
            </div>

            <!-- Controls below visualizer -->
            <div class="controls">
                <button class="control-btn" onclick="previousTrack()" title="Previous">⏮</button>
                <button class="control-btn play" onclick="togglePlay()" id="playBtn" title="Play/Pause">▶</button>
                <button class="control-btn" onclick="nextTrack()" title="Next">⏭</button>
            </div>

            <!-- Track display -->
            <div class="track-display">
                <div class="track-title" id="trackTitle">Ready to play</div>
                <div class="track-artist" id="trackArtist">Add Objkt NFT link to begin</div>
                <div class="progress-container">
                    <div class="progress-bar" id="progressBar"></div>
                </div>
            </div>

            <!-- Input section -->
            <div class="input-section">
                <div class="input-wrapper">
                    <input 
                        type="text" 
                        id="nftInput" 
                        placeholder="Paste Objkt.com NFT link..."
                    >
                    <button class="add-btn" onclick="addTrack()">ADD</button>
                </div>
            </div>

            <div class="loading" id="loading">LOADING TRACK DATA...</div>

            <!-- Playlist -->
            <div class="playlist" id="playlist"></div>

            <div class="status" id="status">Playlist empty</div>
        </div>
    </div>

    <!-- Fullscreen Visualizer Mode -->
    <div class="fullscreen-visualizer" id="fullscreenViz">
        <canvas class="fullscreen-mountains" id="fullscreenMountains"></canvas>
        <canvas class="fullscreen-canvas" id="fullscreenCanvas"></canvas>
        
        <div class="fullscreen-exit" onclick="exitFullscreen()">✕</div>
        
        <div class="fullscreen-controls">
            <div class="fullscreen-info">
                <div class="fullscreen-title" id="fsTitle" onclick="openCurrentObjkt()">Ready to play</div>
                <div class="fullscreen-artist" id="fsArtist">Add Objkt NFT link</div>
            </div>
            <button class="fullscreen-control-btn" onclick="previousTrack()">⏮</button>
            <button class="fullscreen-control-btn play" onclick="togglePlay()" id="fsPlayBtn">▶</button>
            <button class="fullscreen-control-btn" onclick="nextTrack()">⏭</button>
        </div>
    </div>

    <audio id="audioPlayer" preload="auto" crossorigin="anonymous" style="display: none;"></audio>
    <video id="videoPlayer" preload="auto" crossorigin="anonymous" style="display: none;"></video>

    <script>
        let playlist = [];
        let currentTrackIndex = -1;
        let isPlaying = false;
        const audioPlayer = document.getElementById('audioPlayer');
        const videoPlayer = document.getElementById('videoPlayer');
        let activePlayer = audioPlayer; // Track which player is active
        const playBtn = document.getElementById('playBtn');
        const progressBar = document.getElementById('progressBar');

        // LocalStorage key
        const STORAGE_KEY = 'tezos_walkman_playlist';

        // Load playlist from localStorage on page load
        function loadPlaylistFromStorage() {
            try {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (saved) {
                    const data = JSON.parse(saved);
                    playlist = data.playlist || [];
                    currentTrackIndex = data.currentTrackIndex || -1;
                    
                    if (playlist.length > 0) {
                        updatePlaylist();
                        if (currentTrackIndex >= 0 && currentTrackIndex < playlist.length) {
                            loadTrack(currentTrackIndex);
                        }
                        updateStatus();
                    }
                }
            } catch (error) {
                console.error('Error loading playlist from storage:', error);
            }
        }

        // Save playlist to localStorage
        function savePlaylistToStorage() {
            try {
                const data = {
                    playlist: playlist,
                    currentTrackIndex: currentTrackIndex
                };
                localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
            } catch (error) {
                console.error('Error saving playlist to storage:', error);
            }
        }

        // Audio visualizer setup
        const canvas = document.getElementById('visualizer');
        const ctx = canvas.getContext('2d');
        const mountainsCanvas = document.getElementById('mountains');
        const mountainsCtx = mountainsCanvas.getContext('2d');
        let audioContext;
        let analyser;
        let dataArray;
        let bufferLength;
        let animationId;
        let isFullscreen = false;

        // Fullscreen canvases
        const fsCanvas = document.getElementById('fullscreenCanvas');
        const fsCtx = fsCanvas.getContext('2d');
        const fsMountainsCanvas = document.getElementById('fullscreenMountains');
        const fsMountainsCtx = fsMountainsCanvas.getContext('2d');

        // Set canvas sizes
        function resizeCanvas() {
            const pod = document.querySelector('.control-pod');
            canvas.width = pod.offsetWidth;
            canvas.height = pod.offsetHeight;
            mountainsCanvas.width = pod.offsetWidth;
            mountainsCanvas.height = pod.offsetHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Fullscreen functions
        function enterFullscreen() {
            isFullscreen = true;
            document.getElementById('fullscreenViz').classList.add('active');
            fsCanvas.width = window.innerWidth;
            fsCanvas.height = window.innerHeight;
            fsMountainsCanvas.width = window.innerWidth;
            fsMountainsCanvas.height = window.innerHeight;
            updateFullscreenInfo();
        }

        function exitFullscreen() {
            isFullscreen = false;
            document.getElementById('fullscreenViz').classList.remove('active');
        }

        function updateFullscreenInfo() {
            if (currentTrackIndex >= 0 && currentTrackIndex < playlist.length) {
                const track = playlist[currentTrackIndex];
                document.getElementById('fsTitle').textContent = track.title;
                document.getElementById('fsArtist').textContent = track.artist;
            }
        }

        function openCurrentObjkt() {
            if (currentTrackIndex >= 0 && currentTrackIndex < playlist.length) {
                const track = playlist[currentTrackIndex];
                window.open(`https://objkt.com/tokens/${track.contract}/${track.tokenId}`, '_blank');
            }
        }

        // Initialize audio context and analyser
        function initAudioContext() {
            if (!audioContext) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    analyser = audioContext.createAnalyser();
                    analyser.fftSize = 128;
                    bufferLength = analyser.frequencyBinCount;
                    dataArray = new Uint8Array(bufferLength);
                    
                    // Only create source once - will connect to whichever player is active
                    const source = audioContext.createMediaElementSource(activePlayer);
                    source.connect(analyser);
                    analyser.connect(audioContext.destination);
                    
                    console.log('Audio context initialized successfully');
                } catch (error) {
                    console.error('Error initializing audio context:', error);
                    // If error (likely already created), try to get existing source
                }
            }
        }

        // Draw vaporwave mountains that react to audio
        function drawMountains(targetCtx, targetCanvas, scale = 1) {
            if (!analyser) return;
            
            const width = targetCanvas.width;
            const height = targetCanvas.height;
            
            // Clear canvas
            targetCtx.fillStyle = 'transparent';
            targetCtx.clearRect(0, 0, width, height);
            
            // Draw multiple mountain layers
            const layers = 4;
            const bassRange = dataArray.slice(0, 16);
            const avgBass = bassRange.reduce((a, b) => a + b, 0) / bassRange.length;
            
            for (let layer = 0; layer < layers; layer++) {
                const layerHeight = height * 0.6;
                const baseY = height * 0.7 + (layer * 15 * scale);
                const points = 40;
                
                targetCtx.beginPath();
                targetCtx.moveTo(0, height);
                
                // Draw mountain peaks
                for (let i = 0; i <= points; i++) {
                    const x = (width / points) * i;
                    const dataIndex = Math.floor((i / points) * 16);
                    const value = bassRange[dataIndex] || 0;
                    
                    // Create mountain peaks that react to bass
                    const peakHeight = (value / 255) * layerHeight * (1 - layer * 0.2);
                    const y = baseY - peakHeight;
                    
                    targetCtx.lineTo(x, y);
                }
                
                targetCtx.lineTo(width, height);
                targetCtx.closePath();
                
                // Create gradient for each mountain layer
                const gradient = targetCtx.createLinearGradient(0, baseY - layerHeight, 0, height);
                
                // Color scheme: pink -> purple -> cyan based on layer
                if (layer === 0) {
                    gradient.addColorStop(0, `rgba(255, 110, 199, ${0.8 - layer * 0.15})`);
                    gradient.addColorStop(0.5, `rgba(255, 110, 199, ${0.4 - layer * 0.1})`);
                    gradient.addColorStop(1, 'transparent');
                } else if (layer === 1) {
                    gradient.addColorStop(0, `rgba(180, 100, 255, ${0.7 - layer * 0.15})`);
                    gradient.addColorStop(0.5, `rgba(180, 100, 255, ${0.3 - layer * 0.1})`);
                    gradient.addColorStop(1, 'transparent');
                } else if (layer === 2) {
                    gradient.addColorStop(0, `rgba(120, 115, 245, ${0.6 - layer * 0.15})`);
                    gradient.addColorStop(0.5, `rgba(120, 115, 245, ${0.2 - layer * 0.1})`);
                    gradient.addColorStop(1, 'transparent');
                } else {
                    gradient.addColorStop(0, `rgba(0, 255, 204, ${0.5 - layer * 0.15})`);
                    gradient.addColorStop(0.5, `rgba(0, 255, 204, ${0.1 - layer * 0.05})`);
                    gradient.addColorStop(1, 'transparent');
                }
                
                targetCtx.fillStyle = gradient;
                targetCtx.fill();
                
                // Add glow to mountain peaks
                targetCtx.strokeStyle = gradient;
                targetCtx.lineWidth = 2 * scale;
                targetCtx.shadowBlur = 15 * scale;
                targetCtx.shadowColor = layer === 0 ? 'rgba(255, 110, 199, 0.8)' : 
                                       layer === 1 ? 'rgba(180, 100, 255, 0.8)' :
                                       layer === 2 ? 'rgba(120, 115, 245, 0.8)' :
                                       'rgba(0, 255, 204, 0.8)';
                targetCtx.stroke();
                targetCtx.shadowBlur = 0;
            }
        }

        // Retrowave visualizer animation - BADASS VERSION
        let lastPulseTime = 0;
        const pulseThreshold = 100; // Minimum ms between pulses
        
        function drawVisualizer() {
            animationId = requestAnimationFrame(drawVisualizer);
            
            if (!analyser) return;
            
            analyser.getByteFrequencyData(dataArray);
            
            // Draw mountains first (behind visualizer)
            drawMountains(mountainsCtx, mountainsCanvas, 1);
            
            const width = canvas.width;
            const height = canvas.height;
            const centerX = width / 2;
            const centerY = height / 2;
            
            // Calculate audio intensity for body pulse
            const avgValue = dataArray.reduce((a, b) => a + b, 0) / bufferLength;
            const maxValue = Math.max(...dataArray);
            
            // Clear with fade trail effect
            ctx.fillStyle = 'rgba(5, 5, 10, 0.15)';
            ctx.fillRect(0, 0, width, height);
            
            // Draw outer ring glow
            const glowIntensity = maxValue / 255;
            const walkmanEl = document.querySelector('.walkman');
            const walkmanGlow = document.querySelector('.walkman-glow');
            const now = Date.now();
            
            // Continuously update grid based on audio - ALWAYS REACTIVE
            const bassIntensity = Math.max(...dataArray.slice(0, 8)) / 255; // Low frequencies
            const midIntensity = Math.max(...dataArray.slice(8, 32)) / 255; // Mid frequencies
            const highIntensity = Math.max(...dataArray.slice(32, 64)) / 255; // High frequencies
            
            // Grid gets MUCH brighter and scales dramatically with bass
            const gridOpacity = 0.4 + (bassIntensity * 0.6); // 0.4 to 1.0
            const gridScale = 2 + (bassIntensity * 0.8); // 2.0 to 2.8
            const backgroundGlowIntensity = 0.12 + (avgValue / 255) * 0.3; // 0.12 to 0.42
            
            // Update CSS variables for smooth transitions
            walkmanEl.style.setProperty('--grid-opacity', gridOpacity);
            walkmanEl.style.setProperty('--grid-scale', gridScale);
            if (walkmanGlow) {
                walkmanGlow.style.setProperty('--glow-intensity', backgroundGlowIntensity);
            }
            
            // Speed up grid animation on bass hits
            if (bassIntensity > 0.6) {
                walkmanEl.style.setProperty('--grid-speed', '4s');
            } else {
                walkmanEl.style.setProperty('--grid-speed', '8s');
            }
            
            if (maxValue > 180 && (now - lastPulseTime) > pulseThreshold) {
                walkmanEl.classList.add('audio-react');
                
                // Dynamic border glow based on audio intensity
                const intensity = maxValue / 255;
                walkmanEl.style.borderColor = `rgba(255, 215, 0, ${0.3 + intensity * 0.7})`;
                walkmanEl.style.boxShadow = `
                    0 30px 80px rgba(0, 0, 0, 0.8),
                    0 15px 40px rgba(255, 215, 0, ${0.2 + intensity * 0.6}),
                    0 0 ${40 + intensity * 60}px rgba(255, 215, 0, ${intensity * 0.8}),
                    0 0 ${80 + intensity * 120}px rgba(255, 110, 199, ${intensity * 0.4}),
                    inset 0 -8px 25px rgba(0, 0, 0, 0.6),
                    inset 0 8px 25px rgba(255, 215, 0, ${0.1 + intensity * 0.3}),
                    inset 2px 0 15px rgba(255, 215, 0, ${0.15 + intensity * 0.2}),
                    inset -2px 0 15px rgba(255, 110, 199, ${0.1 + intensity * 0.2})
                `;
                
                setTimeout(() => {
                    walkmanEl.classList.remove('audio-react');
                }, 100);
                
                lastPulseTime = now;
            } else if (maxValue < 100) {
                // Reset to normal when quiet
                walkmanEl.style.borderColor = 'rgba(255, 215, 0, 0.3)';
                walkmanEl.style.boxShadow = `
                    0 30px 80px rgba(0, 0, 0, 0.8),
                    0 15px 40px rgba(255, 215, 0, 0.2),
                    inset 0 -8px 25px rgba(0, 0, 0, 0.6),
                    inset 0 8px 25px rgba(255, 215, 0, 0.1),
                    inset 2px 0 15px rgba(255, 215, 0, 0.15),
                    inset -2px 0 15px rgba(255, 110, 199, 0.1)
                `;
            }
            
            // Clear with fade trail effect
            ctx.fillStyle = 'rgba(5, 5, 10, 0.15)';
            ctx.fillRect(0, 0, width, height);
            
            // Draw outer ring glow
            const glowIntensity = maxValue / 255;
            
            ctx.beginPath();
            ctx.arc(centerX, centerY, Math.min(width, height) * 0.42, 0, Math.PI * 2);
            const outerGlow = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.min(width, height) * 0.42);
            outerGlow.addColorStop(0, 'transparent');
            outerGlow.addColorStop(0.8, 'transparent');
            outerGlow.addColorStop(1, `rgba(255, 215, 0, ${glowIntensity * 0.3})`);
            ctx.fillStyle = outerGlow;
            ctx.fill();
            
            // Only update player body if not in fullscreen
            if (!isFullscreen) {
                // Make the entire player body pulse with audio
            const bars = 64;
            const radius = Math.min(width, height) * 0.32;
            
            for (let i = 0; i < bars; i++) {
                const angle = (Math.PI * 2 * i) / bars - Math.PI / 2;
                const dataIndex = Math.floor((i / bars) * bufferLength);
                const value = dataArray[dataIndex] || 0;
                const barHeight = (value / 255) * (radius * 0.8);
                
                // Calculate positions
                const x1 = centerX + Math.cos(angle) * radius;
                const y1 = centerY + Math.sin(angle) * radius;
                const x2 = centerX + Math.cos(angle) * (radius + barHeight);
                const y2 = centerY + Math.sin(angle) * (radius + barHeight);
                
                // Create gradient for each bar - YELLOW/PINK/PURPLE theme
                const gradient = ctx.createLinearGradient(x1, y1, x2, y2);
                
                // Color distribution based on frequency
                if (i < bars / 4) {
                    // Bass - Yellow
                    gradient.addColorStop(0, 'rgba(255, 215, 0, 0.1)');
                    gradient.addColorStop(0.5, `rgba(255, 215, 0, ${0.6 + value/255 * 0.4})`);
                    gradient.addColorStop(1, `rgba(255, 215, 0, ${0.8 + value/255 * 0.2})`);
                } else if (i < (bars / 2)) {
                    // Low-mids - Orange to Pink
                    gradient.addColorStop(0, 'rgba(255, 140, 0, 0.1)');
                    gradient.addColorStop(0.5, `rgba(255, 110, 199, ${0.6 + value/255 * 0.4})`);
                    gradient.addColorStop(1, `rgba(255, 110, 199, ${0.8 + value/255 * 0.2})`);
                } else if (i < (bars * 3) / 4) {
                    // High-mids - Pink to Purple
                    gradient.addColorStop(0, 'rgba(255, 110, 199, 0.1)');
                    gradient.addColorStop(0.5, `rgba(180, 100, 255, ${0.6 + value/255 * 0.4})`);
                    gradient.addColorStop(1, `rgba(120, 115, 245, ${0.8 + value/255 * 0.2})`);
                } else {
                    // Highs - Purple to Cyan
                    gradient.addColorStop(0, 'rgba(120, 115, 245, 0.1)');
                    gradient.addColorStop(0.5, `rgba(0, 255, 204, ${0.6 + value/255 * 0.4})`);
                    gradient.addColorStop(1, `rgba(0, 255, 255, ${0.8 + value/255 * 0.2})`);
                }
                
                // Draw bar with varying thickness based on amplitude
                ctx.beginPath();
                ctx.strokeStyle = gradient;
                ctx.lineWidth = 3 + (value / 255) * 2;
                ctx.lineCap = 'round';
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
                
                // Add intense glow effect
                ctx.shadowBlur = 20 + (value / 255) * 20;
                ctx.shadowColor = gradient;
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                // Add particle effects at bar tips for high values
                if (value > 200) {
                    ctx.beginPath();
                    ctx.arc(x2, y2, 2, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 255, 255, ${(value - 200) / 55})`;
                    ctx.fill();
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#fff';
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            }
            
            // Draw pulsing center rings
            const pulseRadius = radius * 0.25 + (avgValue / 255) * 15;
            
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.arc(centerX, centerY, pulseRadius - i * 8, 0, Math.PI * 2);
                const ringGradient = ctx.createRadialGradient(
                    centerX, centerY, pulseRadius - i * 8 - 5,
                    centerX, centerY, pulseRadius - i * 8 + 5
                );
                ringGradient.addColorStop(0, 'transparent');
                ringGradient.addColorStop(0.5, `rgba(255, 215, 0, ${(1 - i * 0.3) * (avgValue / 255) * 0.5})`);
                ringGradient.addColorStop(1, 'transparent');
                ctx.strokeStyle = ringGradient;
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            
            // Draw center circle with reactive glow
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius * 0.2, 0, Math.PI * 2);
            const centerGradient = ctx.createRadialGradient(
                centerX - 10, centerY - 10, 0,
                centerX, centerY, radius * 0.2
            );
            centerGradient.addColorStop(0, 'rgba(20, 20, 30, 0.95)');
            centerGradient.addColorStop(1, 'rgba(5, 5, 10, 0.98)');
            ctx.fillStyle = centerGradient;
            ctx.fill();
            
            // Outer rim of center circle
            ctx.strokeStyle = `rgba(255, 215, 0, ${0.4 + (avgValue / 255) * 0.6})`;
            ctx.lineWidth = 2;
            ctx.shadowBlur = 15;
            ctx.shadowColor = 'rgba(255, 215, 0, 0.8)';
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            // Inner accent ring
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius * 0.18, 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(255, 110, 199, ${0.2 + (avgValue / 255) * 0.4})`;
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        // Start visualizer
        function startVisualizer() {
            if (!animationId) {
                drawVisualizer();
            }
        }

        // Stop visualizer
        function stopVisualizer() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
        }

        // Extract token ID and contract from Objkt URL
        function extractTokenId(url) {
            // Remove trailing slashes and query params
            url = url.split('?')[0].replace(/\/$/, '');
            
            const patterns = [
                // New Objkt format: objkt.com/asset/CONTRACT/TOKEN
                {
                    regex: /objkt\.com\/asset\/([^\/]+)\/(\d+)/,
                    handler: (match) => ({ contract: match[1], tokenId: match[2] })
                },
                // Tokens format: objkt.com/tokens/CONTRACT/TOKEN
                {
                    regex: /objkt\.com\/tokens\/([^\/]+)\/(\d+)/,
                    handler: (match) => {
                        // Check if it's "hicetnunc" keyword or actual contract
                        if (match[1] === 'hicetnunc') {
                            return { 
                                contract: 'KT1RJ6PbjHpwc3M5rw5s2Nbmefwbuwbdxton', 
                                tokenId: match[2] 
                            };
                        } else {
                            return { contract: match[1], tokenId: match[2] };
                        }
                    }
                },
                // Just a number at the end
                {
                    regex: /\/(\d+)$/,
                    handler: (match) => ({ 
                        contract: 'KT1RJ6PbjHpwc3M5rw5s2Nbmefwbuwbdxton', // assume hic et nunc
                        tokenId: match[1] 
                    })
                }
            ];
            
            for (let pattern of patterns) {
                const match = url.match(pattern.regex);
                if (match) {
                    return pattern.handler(match);
                }
            }
            return null;
        }

        // Fetch NFT metadata from Objkt API
        async function fetchNFTData(url) {
            const tokenInfo = extractTokenId(url);
            if (!tokenInfo) {
                throw new Error('Invalid Objkt URL - please use format: objkt.com/tokens/hicetnunc/TOKEN_ID or objkt.com/asset/CONTRACT/TOKEN_ID');
            }

            console.log('Fetching token:', tokenInfo);

            // Query for the token using correct v3 API schema
            const query = `
                query getToken {
                    token(where: {
                        fa_contract: {_eq: "${tokenInfo.contract}"},
                        token_id: {_eq: "${tokenInfo.tokenId}"}
                    }) {
                        pk
                        token_id
                        name
                        artifact_uri
                        display_uri
                        mime
                        description
                        fa_contract
                        creators {
                            creator_address
                            holder {
                                alias
                                address
                            }
                        }
                    }
                }
            `;

            try {
                const response = await fetch('https://data.objkt.com/v3/graphql', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ query })
                });

                if (!response.ok) {
                    throw new Error(`API request failed with status ${response.status}`);
                }

                const data = await response.json();
                
                console.log('API response:', data);
                
                if (data.errors) {
                    console.error('GraphQL errors:', data.errors);
                    throw new Error('GraphQL query failed: ' + JSON.stringify(data.errors));
                }
                
                if (!data.data || !data.data.token || data.data.token.length === 0) {
                    throw new Error(`NFT not found. Contract: ${tokenInfo.contract}, Token ID: ${tokenInfo.tokenId}`);
                }

                const token = data.data.token[0];
                
                console.log('Token data:', token);
                
                // Check if it's an audio OR video file using the mime field
                const isAudio = token.mime && token.mime.includes('audio');
                const isVideo = token.mime && (token.mime.includes('video') || token.mime.includes('mp4') || token.mime.includes('webm'));
                
                if (!isAudio && !isVideo) {
                    throw new Error(`This NFT is not an audio or video file (mime type: ${token.mime || 'unknown'}). Only audio/video NFTs are supported.`);
                }

                // Handle IPFS URLs
                let audioUrl = token.artifact_uri;
                if (!audioUrl) {
                    throw new Error('No artifact URI found for this NFT');
                }
                
                if (audioUrl.startsWith('ipfs://')) {
                    audioUrl = audioUrl.replace('ipfs://', 'https://ipfs.io/ipfs/');
                } else if (audioUrl.startsWith('Qm')) {
                    audioUrl = 'https://ipfs.io/ipfs/' + audioUrl;
                }

                // Get artist name from creators
                const artistName = token.creators && token.creators[0] 
                    ? (token.creators[0].holder?.alias || token.creators[0].holder?.address?.slice(0, 8) + '...' || token.creators[0].creator_address?.slice(0, 8) + '...')
                    : 'Unknown Artist';

                return {
                    title: token.name || 'Untitled',
                    artist: artistName,
                    url: audioUrl,
                    tokenId: token.token_id,
                    contract: token.fa_contract,
                    mime: token.mime
                };
            } catch (error) {
                console.error('Fetch error:', error);
                throw error;
            }
        }

        async function addTrack() {
            const input = document.getElementById('nftInput');
            const url = input.value.trim();
            
            if (!url) {
                alert('Please enter a valid Objkt URL');
                return;
            }

            const loading = document.getElementById('loading');
            loading.classList.add('active');

            try {
                const trackData = await fetchNFTData(url);
                playlist.push(trackData);
                updatePlaylist();
                input.value = '';
                
                if (currentTrackIndex === -1) {
                    currentTrackIndex = 0;
                    loadTrack(0);
                }
                
                updateStatus();
                savePlaylistToStorage(); // Save to localStorage
            } catch (error) {
                alert('Error loading track: ' + error.message);
                console.error(error);
            } finally {
                loading.classList.remove('active');
            }
        }

        function updatePlaylist() {
            const playlistEl = document.getElementById('playlist');
            playlistEl.innerHTML = '';
            
            playlist.forEach((track, index) => {
                const item = document.createElement('div');
                item.className = 'playlist-item' + (index === currentTrackIndex ? ' active' : '');
                
                const objktUrl = `https://objkt.com/tokens/${track.contract}/${track.tokenId}`;
                
                // Add delete button
                const deleteBtn = document.createElement('span');
                deleteBtn.innerHTML = '✕';
                deleteBtn.className = 'delete-btn';
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    removeTrack(index);
                };
                
                item.innerHTML = `
                    <div class="playlist-item-title"><a href="${objktUrl}" target="_blank" title="View on Objkt" onclick="event.stopPropagation()">${track.title}</a></div>
                    <div class="playlist-item-artist">${track.artist}</div>
                `;
                
                // Make item clickable to play track (but not the link itself)
                item.onclick = (e) => {
                    if (e.target.tagName !== 'A') {
                        currentTrackIndex = index;
                        loadTrack(index);
                        play();
                        savePlaylistToStorage();
                    }
                };
                
                item.appendChild(deleteBtn);
                playlistEl.appendChild(item);
            });
        }

        function removeTrack(index) {
            if (confirm('Remove this track from playlist?')) {
                playlist.splice(index, 1);
                
                // Update current track index
                if (currentTrackIndex === index) {
                    if (playlist.length > 0) {
                        currentTrackIndex = Math.min(currentTrackIndex, playlist.length - 1);
                        loadTrack(currentTrackIndex);
                    } else {
                        currentTrackIndex = -1;
                        document.getElementById('trackTitle').textContent = 'Ready to play';
                        document.getElementById('trackArtist').textContent = 'Add Objkt NFT link to begin';
                        pause();
                    }
                } else if (index < currentTrackIndex) {
                    currentTrackIndex--;
                }
                
                updatePlaylist();
                updateStatus();
                savePlaylistToStorage();
            }
        }

        function loadTrack(index) {
            if (index < 0 || index >= playlist.length) return;
            
            const track = playlist[index];
            
            // Determine if this is a video or audio file
            const isVideo = track.mime && (track.mime.includes('video') || track.mime.includes('mp4') || track.mime.includes('webm'));
            
            // Pause both players first
            audioPlayer.pause();
            videoPlayer.pause();
            
            // Set the active player based on file type
            if (isVideo) {
                activePlayer = videoPlayer;
                videoPlayer.src = track.url;
            } else {
                activePlayer = audioPlayer;
                audioPlayer.src = track.url;
            }
            
            // Create Objkt URL
            const objktUrl = `https://objkt.com/tokens/${track.contract}/${track.tokenId}`;
            
            // Make title clickable
            document.getElementById('trackTitle').innerHTML = `<a href="${objktUrl}" target="_blank" title="View on Objkt">${track.title}</a>`;
            document.getElementById('trackArtist').textContent = track.artist;
            
            updatePlaylist();
            savePlaylistToStorage(); // Save current track position
        }

        function togglePlay() {
            if (playlist.length === 0) {
                alert('Add tracks to your playlist first!');
                return;
            }

            if (isPlaying) {
                pause();
            } else {
                play();
            }
        }

        function play() {
            initAudioContext();
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            
            activePlayer.play();
            isPlaying = true;
            playBtn.innerHTML = '⏸';
            document.getElementById('led1').classList.remove('off');
            startVisualizer();
        }

        function pause() {
            activePlayer.pause();
            isPlaying = false;
            playBtn.innerHTML = '▶';
            document.getElementById('led1').classList.add('off');
        }

        function nextTrack() {
            if (playlist.length === 0) return;
            
            currentTrackIndex = (currentTrackIndex + 1) % playlist.length;
            loadTrack(currentTrackIndex);
            
            if (isPlaying) {
                play();
            }
        }

        function previousTrack() {
            if (playlist.length === 0) return;
            
            currentTrackIndex = (currentTrackIndex - 1 + playlist.length) % playlist.length;
            loadTrack(currentTrackIndex);
            
            if (isPlaying) {
                play();
            }
        }

        function updateStatus() {
            const status = document.getElementById('status');
            if (playlist.length === 0) {
                status.textContent = 'Playlist empty';
            } else {
                status.textContent = `${playlist.length} track${playlist.length > 1 ? 's' : ''} loaded`;
            }
        }

        // Audio/Video event listeners
        function setupPlayerListeners(player) {
            player.addEventListener('timeupdate', () => {
                const progress = (player.currentTime / player.duration) * 100;
                progressBar.style.width = progress + '%';
            });

            player.addEventListener('ended', () => {
                nextTrack();
            });

            player.addEventListener('error', (e) => {
                console.error('Playback error:', e);
                alert('Error playing media. The file might be unavailable or in an unsupported format.');
            });
        }

        setupPlayerListeners(audioPlayer);
        setupPlayerListeners(videoPlayer);

        // Allow Enter key to add tracks
        document.getElementById('nftInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                addTrack();
            }
        });

        // Load saved playlist on page load
        loadPlaylistFromStorage();

        // Start visualizer even when paused for aesthetic
        drawVisualizer();
    </script>
</body>
</html>
